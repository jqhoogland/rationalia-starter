/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// main.ts
__export(exports, {
  default: () => TagFolderPlugin
});
var import_obsidian3 = __toModule(require("obsidian"));

// node_modules/svelte/internal/index.mjs
function noop() {
}
function assign(tar, src) {
  for (const k in src)
    tar[k] = src[k];
  return tar;
}
function run(fn) {
  return fn();
}
function blank_object() {
  return Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
function create_slot(definition, ctx, $$scope, fn) {
  if (definition) {
    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
    return definition[0](slot_ctx);
  }
}
function get_slot_context(definition, ctx, $$scope, fn) {
  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;
}
function get_slot_changes(definition, $$scope, dirty, fn) {
  if (definition[2] && fn) {
    const lets = definition[2](fn(dirty));
    if ($$scope.dirty === void 0) {
      return lets;
    }
    if (typeof lets === "object") {
      const merged = [];
      const len = Math.max($$scope.dirty.length, lets.length);
      for (let i = 0; i < len; i += 1) {
        merged[i] = $$scope.dirty[i] | lets[i];
      }
      return merged;
    }
    return $$scope.dirty | lets;
  }
  return $$scope.dirty;
}
function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
  if (slot_changes) {
    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
    slot.p(slot_context, slot_changes);
  }
}
function get_all_dirty_from_scope($$scope) {
  if ($$scope.ctx.length > 32) {
    const dirty = [];
    const length = $$scope.ctx.length / 32;
    for (let i = 0; i < length; i++) {
      dirty[i] = -1;
    }
    return dirty;
  }
  return -1;
}
var tasks = new Set();
var is_hydrating = false;
function start_hydrating() {
  is_hydrating = true;
}
function end_hydrating() {
  is_hydrating = false;
}
function append(target, node) {
  target.appendChild(node);
}
function append_styles(target, style_sheet_id, styles) {
  const append_styles_to = get_root_for_style(target);
  if (!append_styles_to.getElementById(style_sheet_id)) {
    const style = element("style");
    style.id = style_sheet_id;
    style.textContent = styles;
    append_stylesheet(append_styles_to, style);
  }
}
function get_root_for_style(node) {
  if (!node)
    return document;
  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
  if (root && root.host) {
    return root;
  }
  return node.ownerDocument;
}
function append_stylesheet(node, style) {
  append(node.head || node, style);
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  node.parentNode.removeChild(node);
}
function destroy_each(iterations, detaching) {
  for (let i = 0; i < iterations.length; i += 1) {
    if (iterations[i])
      iterations[i].d(detaching);
  }
}
function element(name) {
  return document.createElement(name);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function empty() {
  return text("");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text2, data) {
  data = "" + data;
  if (text2.wholeText !== data)
    text2.data = data;
}
function set_input_value(input, value) {
  input.value = value == null ? "" : value;
}
function set_style(node, key, value, important) {
  node.style.setProperty(key, value, important ? "important" : "");
}
function toggle_class(element2, name, toggle) {
  element2.classList[toggle ? "add" : "remove"](name);
}
var active_docs = new Set();
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(fn) {
  get_current_component().$$.on_mount.push(fn);
}
var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise = Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
var flushing = false;
var seen_callbacks = new Set();
function flush() {
  if (flushing)
    return;
  flushing = true;
  do {
    for (let i = 0; i < dirty_components.length; i += 1) {
      const component = dirty_components[i];
      set_current_component(component);
      update(component.$$);
    }
    set_current_component(null);
    dirty_components.length = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  flushing = false;
  seen_callbacks.clear();
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
var outroing = new Set();
var outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback) {
  if (block && block.o) {
    if (outroing.has(block))
      return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback) {
        if (detach2)
          block.d(1);
        callback();
      }
    });
    block.o(local);
  }
}
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : global;
var boolean_attributes = new Set([
  "allowfullscreen",
  "allowpaymentrequest",
  "async",
  "autofocus",
  "autoplay",
  "checked",
  "controls",
  "default",
  "defer",
  "disabled",
  "formnovalidate",
  "hidden",
  "ismap",
  "loop",
  "multiple",
  "muted",
  "nomodule",
  "novalidate",
  "open",
  "playsinline",
  "readonly",
  "required",
  "reversed",
  "selected"
]);
function create_component(block) {
  block && block.c();
}
function mount_component(component, target, anchor, customElement) {
  const { fragment, on_mount, on_destroy, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  if (!customElement) {
    add_render_callback(() => {
      const new_on_destroy = on_mount.map(run).filter(is_function);
      if (on_destroy) {
        on_destroy.push(...new_on_destroy);
      } else {
        run_all(new_on_destroy);
      }
      component.$$.on_mount = [];
    });
  }
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}
function init(component, options, instance5, create_fragment5, not_equal, props, append_styles2, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: null,
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles2 && append_styles2($$.root);
  let ready = false;
  $$.ctx = instance5 ? instance5(component, options.props || {}, (i, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
      if (!$$.skip_bound && $$.bound[i])
        $$.bound[i](value);
      if (ready)
        make_dirty(component, i);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment5 ? create_fragment5($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      start_hydrating();
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor, options.customElement);
    end_hydrating();
    flush();
  }
  set_current_component(parent_component);
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({ mode: "open" });
    }
    connectedCallback() {
      const { on_mount } = this.$$;
      this.$$.on_disconnect = on_mount.map(run).filter(is_function);
      for (const key in this.$$.slotted) {
        this.appendChild(this.$$.slotted[key]);
      }
    }
    attributeChangedCallback(attr2, _oldValue, newValue) {
      this[attr2] = newValue;
    }
    disconnectedCallback() {
      run_all(this.$$.on_disconnect);
    }
    $destroy() {
      destroy_component(this, 1);
      this.$destroy = noop;
    }
    $on(type, callback) {
      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
      callbacks.push(callback);
      return () => {
        const index = callbacks.indexOf(callback);
        if (index !== -1)
          callbacks.splice(index, 1);
      };
    }
    $set($$props) {
      if (this.$$set && !is_empty($$props)) {
        this.$$.skip_bound = true;
        this.$$set($$props);
        this.$$.skip_bound = false;
      }
    }
  };
}
var SvelteComponent = class {
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  $on(type, callback) {
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1)
        callbacks.splice(index, 1);
    };
  }
  $set($$props) {
    if (this.$$set && !is_empty($$props)) {
      this.$$.skip_bound = true;
      this.$$set($$props);
      this.$$.skip_bound = false;
    }
  }
};

// node_modules/svelte/store/index.mjs
var subscriber_queue = [];
function writable(value, start = noop) {
  let stop;
  const subscribers = new Set();
  function set(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue.length; i += 2) {
            subscriber_queue[i][0](subscriber_queue[i + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update2(fn) {
    set(fn(value));
  }
  function subscribe2(run2, invalidate = noop) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set) || noop;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0) {
        stop();
        stop = null;
      }
    };
  }
  return { set, update: update2, subscribe: subscribe2 };
}

// store.ts
var treeRoot = writable();
var currentFile = writable("");
var maxDepth = writable(0);
var filterString = writable("");
var tagInfo = writable({});

// types.ts
var SUBTREE_MARK = "\u2192 ";
var SUBTREE_MARK_REGEX = /\/â†’ /g;
var DEFAULT_SETTINGS = {
  displayMethod: "NAME",
  alwaysOpen: false,
  ignoreDocTags: "",
  ignoreTags: "",
  hideOnRootTags: "",
  sortType: "DISPNAME_ASC",
  sortTypeTag: "NAME_ASC",
  expandLimit: 0,
  disableNestedTags: false,
  hideItems: "NONE",
  ignoreFolders: "",
  scanDelay: 250,
  useTitle: true,
  reduceNestedParent: true,
  frontmatterKey: "title",
  useTagInfo: false,
  tagInfo: "pininfo.md",
  mergeRedundantCombination: false,
  useVirtualTag: false
};
var VIEW_TYPE_SCROLL = "tagfolder-view-scroll";
var EPOCH_MINUTE = 60;
var EPOCH_HOUR = EPOCH_MINUTE * 60;
var EPOCH_DAY = EPOCH_HOUR * 24;
var FRESHNESS_1 = "FRESHNESS_01";
var FRESHNESS_2 = "FRESHNESS_02";
var FRESHNESS_3 = "FRESHNESS_03";
var FRESHNESS_4 = "FRESHNESS_04";
var FRESHNESS_5 = "FRESHNESS_05";
var tagDispDict = {
  FRESHNESS_01: "\u{1F550}",
  FRESHNESS_02: "\u{1F4D6}",
  FRESHNESS_03: "\u{1F4D7}",
  FRESHNESS_04: "\u{1F4DA}",
  FRESHNESS_05: "\u{1F5C4}",
  _VIRTUAL_TAG_FRESHNESS: "\u231B"
};

// util.ts
function unique(items) {
  return [...new Set([...items])];
}
function allTags(entry) {
  var _a;
  if ("tags" in entry)
    return entry.tags;
  return unique([...((_a = entry == null ? void 0 : entry.descendants) != null ? _a : []).flatMap((e) => e.tags), ...entry.children.flatMap((e) => "tag" in e ? allTags(e) : e.tags).filter((e) => e)]);
}
function isAutoExpandTree(entry) {
  var _a;
  if ("tag" in entry) {
    const childrenTags = entry.children.filter((e) => "tag" in e);
    const childrenItems = ((_a = entry.allDescendants) != null ? _a : entry.children).filter((e) => "tags" in e);
    if (childrenTags.length == 0)
      return false;
    if (entry.itemsCount == 1)
      return true;
    if (childrenTags.length == 1 && childrenItems.length == 0) {
      return true;
    }
    const entryAllTags = ancestorToTags(entry.ancestors.slice(1));
    const entryTags = ancestorToLongestTag(entryAllTags);
    const childrenItemsTag = childrenItems.map((e) => __spreadProps(__spreadValues({}, e), {
      tags: e.tags.map((oldTag) => entryTags.reduce((trimTag, tagToTrim) => trimTag.startsWith(tagToTrim + "/") ? trimTag.substring(tagToTrim.length + 1) : trimTag, oldTag)).filter((e2) => e2)
    }));
    const firstLevelChildren = unique([
      ...childrenItemsTag.flatMap((e) => e.tags.map((ee) => ee.substring(0, (ee + "/").indexOf("/")))),
      ...childrenTags.map((e) => e.tag.startsWith(SUBTREE_MARK) ? e.tag.substring(SUBTREE_MARK.length) : e.tag)
    ]).filter((e) => !entryAllTags.contains(e));
    if (firstLevelChildren.length == 1) {
      return true;
    }
    if (childrenTags.length == 1 && childrenItems.length > 1) {
      const sTags = allTags(entry).join("-").toLocaleLowerCase();
      for (const child of childrenItems) {
        const cTags = allTags(child).join("-").toLocaleLowerCase();
        if (sTags != cTags) {
          return false;
        }
      }
      return true;
    }
  }
  return false;
}
function omittedTags(entry) {
  var _a;
  const childrenTags = entry.children.filter((e) => "tag" in e);
  const childrenItems = ((_a = entry.allDescendants) != null ? _a : entry.children).filter((e) => "tags" in e);
  if (childrenTags.length > 0)
    return false;
  const tx = childrenItems.map((e) => [...e.tags].sort().join("-"));
  if (tx.length != 1 && entry.itemsCount != 1)
    return false;
  const tags = unique(childrenItems.flatMap((e) => e.tags));
  const ancestorTags = ancestorToTags(entry.ancestors).map((e) => e.toLocaleLowerCase());
  const lastT = tags.filter((e) => !ancestorTags.contains(e.toLocaleLowerCase()));
  if (lastT.length) {
    return lastT;
  }
  return false;
}
function ancestorToTags(ancestors) {
  const SUBTREE_MARK_LENGTH = SUBTREE_MARK.length;
  return ancestors.reduce((p, i) => !i.startsWith(SUBTREE_MARK) ? [...p, i] : [
    ...p,
    p.pop() + "/" + i.substring(SUBTREE_MARK_LENGTH)
  ], []);
}
function ancestorToLongestTag(ancestors) {
  return ancestors.reduceRight((a, e) => !a ? [e] : a[0].startsWith(e) ? a : [e, ...a], null);
}
function isSpecialTag(tagSrc) {
  const tag = tagSrc.startsWith(SUBTREE_MARK) ? tagSrc.substring(SUBTREE_MARK.length) : tagSrc;
  return tag == "_untagged" || tag in tagDispDict;
}
function renderSpecialTag(tagSrc) {
  const tag = tagSrc.startsWith(SUBTREE_MARK) ? tagSrc.substring(SUBTREE_MARK.length) : tagSrc;
  return tag in tagDispDict ? tagDispDict[tag] : tag;
}
function secondsToFreshness(totalAsMSec) {
  const totalAsSec = ~~(totalAsMSec / 1e3);
  const sign = totalAsSec / Math.abs(totalAsSec);
  const totalSec = ~~(totalAsSec * sign);
  if (totalSec < EPOCH_HOUR)
    return FRESHNESS_1;
  if (totalSec < EPOCH_HOUR * 6)
    return FRESHNESS_2;
  if (totalSec < EPOCH_DAY * 3)
    return FRESHNESS_3;
  if (totalSec < EPOCH_DAY * 7)
    return FRESHNESS_4;
  return FRESHNESS_5;
}

// TreeItemComponent.svelte
function add_css(target) {
  append_styles(target, "svelte-brpr9m", ".lsl-f.svelte-brpr9m.svelte-brpr9m{flex-direction:row;display:flex;flex-grow:1;max-width:100%}.tagfolder-titletagname.svelte-brpr9m.svelte-brpr9m{flex-grow:1;max-width:calc(100% - 2em);width:calc(100% - 2em);text-overflow:ellipsis;overflow:hidden;white-space:nowrap;overflow:hidden}.nav-folder-title-content.svelte-brpr9m:hover .tagfolder-quantity span.svelte-brpr9m{background-color:var(--interactive-accent-hover);color:var(--text-on-accent)}.tagfolder-quantity.svelte-brpr9m span.svelte-brpr9m{background-color:var(--background-secondary-alt);border-radius:4px;padding:2px 4px}.tagfolder-quantity.svelte-brpr9m.svelte-brpr9m{width:3em;text-align:right;cursor:pointer}.tag-folder-title.svelte-brpr9m.svelte-brpr9m{max-width:100%}");
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[34] = list[i];
  return child_ctx;
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[34] = list[i];
  return child_ctx;
}
function create_if_block_4(ctx) {
  let div2;
  let div1;
  let div0;
  let t_value = ctx[0].displayName + "";
  let t;
  let mounted;
  let dispose;
  return {
    c() {
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      t = text(t_value);
      attr(div0, "class", "nav-file-title-content");
      attr(div1, "class", "nav-file-title");
      toggle_class(div1, "is-active", ctx[9]);
      attr(div2, "class", "nav-file");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div1);
      append(div1, div0);
      append(div0, t);
      if (!mounted) {
        dispose = [
          listen(div1, "click", ctx[31]),
          listen(div1, "mouseover", ctx[32]),
          listen(div1, "focus", focus_handler),
          listen(div1, "contextmenu", function() {
            if (is_function(ctx[17](ctx[0])))
              ctx[17](ctx[0]).apply(this, arguments);
          })
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & 1 && t_value !== (t_value = ctx[0].displayName + ""))
        set_data(t, t_value);
      if (dirty[0] & 512) {
        toggle_class(div1, "is-active", ctx[9]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div2);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_2(ctx) {
  let div5;
  let div4;
  let div0;
  let t0;
  let div3;
  let div1;
  let t1;
  let t2;
  let t3;
  let div2;
  let span;
  let t4_value = ctx[0].itemsCount + "";
  let t4;
  let t5;
  let current;
  let mounted;
  let dispose;
  let if_block = ctx[12].length > 0 && create_if_block_3(ctx);
  return {
    c() {
      div5 = element("div");
      div4 = element("div");
      div0 = element("div");
      div0.innerHTML = `<svg viewBox="0 0 100 100" class="right-triangle" width="8" height="8"><path fill="currentColor" stroke="currentColor" d="M94.9,20.8c-1.4-2.5-4.1-4.1-7.1-4.1H12.2c-3,0-5.7,1.6-7.1,4.1c-1.3,2.4-1.2,5.2,0.2,7.6L43.1,88c1.5,2.3,4,3.7,6.9,3.7 s5.4-1.4,6.9-3.7l37.8-59.6C96.1,26,96.2,23.2,94.9,20.8L94.9,20.8z"></path></svg>`;
      t0 = space();
      div3 = element("div");
      div1 = element("div");
      t1 = text(ctx[10]);
      t2 = text(ctx[11]);
      t3 = space();
      div2 = element("div");
      span = element("span");
      t4 = text(t4_value);
      t5 = space();
      if (if_block)
        if_block.c();
      attr(div0, "class", "nav-folder-collapse-indicator collapse-icon");
      attr(div1, "class", "tagfolder-titletagname svelte-brpr9m");
      attr(span, "class", "itemscount svelte-brpr9m");
      attr(div2, "class", "tagfolder-quantity itemscount svelte-brpr9m");
      attr(div3, "class", "nav-folder-title-content lsl-f svelte-brpr9m");
      attr(div4, "class", "nav-folder-title tag-folder-title svelte-brpr9m");
      toggle_class(div4, "is-active", ctx[0].children && ctx[6] && ctx[9]);
      attr(div5, "class", "nav-folder");
      toggle_class(div5, "is-collapsed", ctx[6]);
    },
    m(target, anchor) {
      insert(target, div5, anchor);
      append(div5, div4);
      append(div4, div0);
      append(div4, t0);
      append(div4, div3);
      append(div3, div1);
      append(div1, t1);
      append(div1, t2);
      append(div3, t3);
      append(div3, div2);
      append(div2, span);
      append(span, t4);
      append(div5, t5);
      if (if_block)
        if_block.m(div5, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(div2, "click", ctx[29]),
          listen(div4, "click", ctx[30]),
          listen(div4, "contextmenu", function() {
            if (is_function(ctx[17](ctx[0])))
              ctx[17](ctx[0]).apply(this, arguments);
          })
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (!current || dirty[0] & 1024)
        set_data(t1, ctx[10]);
      if (!current || dirty[0] & 2048)
        set_data(t2, ctx[11]);
      if ((!current || dirty[0] & 1) && t4_value !== (t4_value = ctx[0].itemsCount + ""))
        set_data(t4, t4_value);
      if (dirty[0] & 577) {
        toggle_class(div4, "is-active", ctx[0].children && ctx[6] && ctx[9]);
      }
      if (ctx[12].length > 0) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty[0] & 4096) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_3(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div5, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (dirty[0] & 64) {
        toggle_class(div5, "is-collapsed", ctx[6]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div5);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block(ctx) {
  let if_block_anchor;
  let current;
  let if_block = ctx[12].length > 0 && create_if_block_1(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[12].length > 0) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & 4096) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_3(ctx) {
  let div;
  let current;
  let each_value_1 = ctx[12];
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div, "class", "nav-folder-children");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & 12350) {
        each_value_1 = ctx2[12];
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_1(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div, null);
          }
        }
        group_outros();
        for (i = each_value_1.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block_1(ctx) {
  let treeitemcomponent;
  let current;
  treeitemcomponent = new TreeItemComponent({
    props: {
      entry: ctx[34],
      openfile: ctx[2],
      hoverPreview: ctx[1],
      expandFolder: ctx[3],
      showMenu: ctx[4],
      openScrollView: ctx[5],
      path: ctx[13]
    }
  });
  return {
    c() {
      create_component(treeitemcomponent.$$.fragment);
    },
    m(target, anchor) {
      mount_component(treeitemcomponent, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const treeitemcomponent_changes = {};
      if (dirty[0] & 4096)
        treeitemcomponent_changes.entry = ctx2[34];
      if (dirty[0] & 4)
        treeitemcomponent_changes.openfile = ctx2[2];
      if (dirty[0] & 2)
        treeitemcomponent_changes.hoverPreview = ctx2[1];
      if (dirty[0] & 8)
        treeitemcomponent_changes.expandFolder = ctx2[3];
      if (dirty[0] & 16)
        treeitemcomponent_changes.showMenu = ctx2[4];
      if (dirty[0] & 32)
        treeitemcomponent_changes.openScrollView = ctx2[5];
      if (dirty[0] & 8192)
        treeitemcomponent_changes.path = ctx2[13];
      treeitemcomponent.$set(treeitemcomponent_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(treeitemcomponent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(treeitemcomponent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(treeitemcomponent, detaching);
    }
  };
}
function create_if_block_1(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ctx[12];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & 13374) {
        each_value = ctx2[12];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_each_block(ctx) {
  let treeitemcomponent;
  let current;
  treeitemcomponent = new TreeItemComponent({
    props: {
      entry: ctx[34],
      openfile: ctx[2],
      hoverPreview: ctx[1],
      expandFolder: ctx[3],
      showMenu: ctx[4],
      openScrollView: ctx[5],
      skippedTag: ctx[10],
      path: ctx[13]
    }
  });
  return {
    c() {
      create_component(treeitemcomponent.$$.fragment);
    },
    m(target, anchor) {
      mount_component(treeitemcomponent, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const treeitemcomponent_changes = {};
      if (dirty[0] & 4096)
        treeitemcomponent_changes.entry = ctx2[34];
      if (dirty[0] & 4)
        treeitemcomponent_changes.openfile = ctx2[2];
      if (dirty[0] & 2)
        treeitemcomponent_changes.hoverPreview = ctx2[1];
      if (dirty[0] & 8)
        treeitemcomponent_changes.expandFolder = ctx2[3];
      if (dirty[0] & 16)
        treeitemcomponent_changes.showMenu = ctx2[4];
      if (dirty[0] & 32)
        treeitemcomponent_changes.openScrollView = ctx2[5];
      if (dirty[0] & 1024)
        treeitemcomponent_changes.skippedTag = ctx2[10];
      if (dirty[0] & 8192)
        treeitemcomponent_changes.path = ctx2[13];
      treeitemcomponent.$set(treeitemcomponent_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(treeitemcomponent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(treeitemcomponent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(treeitemcomponent, detaching);
    }
  };
}
function fallback_block(ctx) {
  let show_if;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block, create_if_block_2, create_if_block_4];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[8])
      return 0;
    if (show_if == null || dirty[0] & 129)
      show_if = !!("tag" in ctx2[0] && (ctx2[14] <= ctx2[7] || ctx2[0].tag.startsWith(SUBTREE_MARK)));
    if (show_if)
      return 1;
    if ("path" in ctx2[0])
      return 2;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, [-1, -1]))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment(ctx) {
  let current;
  const default_slot_template = ctx[28].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[27], null);
  const default_slot_or_fallback = default_slot || fallback_block(ctx);
  return {
    c() {
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
    },
    m(target, anchor) {
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & 134217728)) {
          update_slot_base(default_slot, default_slot_template, ctx2, ctx2[27], !current ? get_all_dirty_from_scope(ctx2[27]) : get_slot_changes(default_slot_template, ctx2[27], dirty, null), null);
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty[0] & 16383)) {
          default_slot_or_fallback.p(ctx2, !current ? [-1, -1] : dirty);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d(detaching) {
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
    }
  };
}
function getItemPath(item, basepath) {
  if (item && "tag" in item) {
    return basepath + item.tag + "/";
  }
  return basepath;
}
function getFilenames(entry) {
  if (entry.allDescendants == null) {
    return [];
  } else {
    const filenames = entry.allDescendants.map((e) => e.path);
    return Array.from(new Set([...filenames]));
  }
}
var focus_handler = () => {
};
function instance($$self, $$props, $$invalidate) {
  let currentPath;
  let curTaginfo;
  let tagMark;
  let convertedTag;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { entry } = $$props;
  let { hoverPreview } = $$props;
  let { openfile } = $$props;
  let { expandFolder } = $$props;
  let { showMenu } = $$props;
  let { path } = $$props;
  let { skippedTag } = $$props;
  let { openScrollView } = $$props;
  let collapsed = true;
  let isSelected = false;
  const currentDepth = path.replace(SUBTREE_MARK_REGEX, "###").split("/").length;
  let _maxDepth = currentDepth + 1;
  function toggleFolder(evt, entry2) {
    if (evt.target instanceof HTMLElement && evt.target.hasClass("itemscount"))
      return;
    if ("tag" in entry2) {
      expandFolder(entry2, collapsed);
      $$invalidate(6, collapsed = !collapsed);
    }
  }
  function openfileLocal(entry2) {
    if ("path" in entry2)
      openfile(entry2.path);
  }
  function handleContextMenu(e, path2, entry2) {
    showMenu(e, path2, entry2);
  }
  function contextMenuFunc(entry2) {
    const _path = currentPath;
    const _entry = entry2;
    return (e) => {
      handleContextMenu(e, _path, _entry);
    };
  }
  function handleMouseover(e, entry2) {
    if (entry2 && "path" in entry2)
      hoverPreview(e, entry2.path);
  }
  function handleOpenScroll(e, entry2) {
    if ("tag" in entry2) {
      openScrollView(null, "", entry2.ancestors.join("/"), entry2.allDescendants.map((e2) => e2.path));
      e.preventDefault();
    }
  }
  currentFile.subscribe((path2) => {
    $$invalidate(9, isSelected = false);
    if ("tags" in entry && entry.path == path2) {
      $$invalidate(9, isSelected = true);
    }
    if ("tag" in entry && getFilenames(entry).indexOf(path2) !== -1) {
      $$invalidate(9, isSelected = true);
    }
  });
  let _tagInfo = {};
  maxDepth.subscribe((depth) => {
    $$invalidate(7, _maxDepth = depth);
    if (depth == 0) {
      $$invalidate(7, _maxDepth = currentDepth + 1);
    }
  });
  tagInfo.subscribe((info) => {
    $$invalidate(22, _tagInfo = info);
  });
  let tagTitle = "";
  let showOnlyChildren = false;
  let ellipsisMark = "";
  let omitTags = [];
  let children2 = [];
  const click_handler = (e) => handleOpenScroll(e, entry);
  const click_handler_1 = (evt) => toggleFolder(evt, entry);
  const click_handler_2 = () => openfileLocal(entry);
  const mouseover_handler = (e) => handleMouseover(e, entry);
  $$self.$$set = ($$props2) => {
    if ("entry" in $$props2)
      $$invalidate(0, entry = $$props2.entry);
    if ("hoverPreview" in $$props2)
      $$invalidate(1, hoverPreview = $$props2.hoverPreview);
    if ("openfile" in $$props2)
      $$invalidate(2, openfile = $$props2.openfile);
    if ("expandFolder" in $$props2)
      $$invalidate(3, expandFolder = $$props2.expandFolder);
    if ("showMenu" in $$props2)
      $$invalidate(4, showMenu = $$props2.showMenu);
    if ("path" in $$props2)
      $$invalidate(20, path = $$props2.path);
    if ("skippedTag" in $$props2)
      $$invalidate(21, skippedTag = $$props2.skippedTag);
    if ("openScrollView" in $$props2)
      $$invalidate(5, openScrollView = $$props2.openScrollView);
    if ("$$scope" in $$props2)
      $$invalidate(27, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 8388609) {
      $: {
        $$invalidate(8, showOnlyChildren = false);
        $$invalidate(11, ellipsisMark = "");
        $$invalidate(23, omitTags = []);
        if ("tag" in entry) {
          $$invalidate(8, showOnlyChildren = isAutoExpandTree(entry));
          const omitTag = omittedTags(entry);
          if (omitTag !== false) {
            $$invalidate(23, omitTags = [
              ...omitTag.map((e) => e.split("/").map((ee) => renderSpecialTag(ee)).join("/"))
            ]);
            $$invalidate(11, ellipsisMark = "/" + omitTags.join("/"));
          }
        }
      }
    }
    if ($$self.$$.dirty[0] & 9437185) {
      $:
        $$invalidate(13, currentPath = getItemPath(entry, path) + omitTags.map((e) => "/" + e).join(""));
    }
    if ($$self.$$.dirty[0] & 4194305) {
      $:
        $$invalidate(26, curTaginfo = "tag" in entry && entry.tag in _tagInfo ? _tagInfo[entry.tag] : null);
    }
    if ($$self.$$.dirty[0] & 67108864) {
      $:
        $$invalidate(25, tagMark = !curTaginfo ? "" : "mark" in curTaginfo && curTaginfo.mark ? curTaginfo.mark : "\u{1F4CC}");
    }
    if ($$self.$$.dirty[0] & 1) {
      $:
        $$invalidate(24, convertedTag = "tag" in entry ? renderSpecialTag(entry.tag) : "");
    }
    if ($$self.$$.dirty[0] & 52428801) {
      $:
        $$invalidate(10, tagTitle = "tag" in entry ? `${skippedTag ? `${skippedTag}${entry.tag.startsWith(SUBTREE_MARK) ? " " : "/"}` : ""}${tagMark}${convertedTag}` : "");
    }
    if ($$self.$$.dirty[0] & 449) {
      $: {
        let cx = [];
        if ("tag" in entry) {
          if (showOnlyChildren) {
            cx = [...cx, ...entry.children.filter((e) => "tag" in e)];
          } else {
            if (entry.children && !collapsed) {
              cx = [...cx, ...entry.children.filter((e) => "tag" in e)];
            }
            if (_maxDepth != 1 && currentDepth > _maxDepth && entry.allDescendants && !collapsed) {
              cx = [...cx, ...entry.allDescendants];
            }
            if (entry.descendants && !collapsed) {
              cx = [...cx, ...entry.descendants];
            }
          }
          $$invalidate(12, children2 = cx);
        }
      }
    }
  };
  return [
    entry,
    hoverPreview,
    openfile,
    expandFolder,
    showMenu,
    openScrollView,
    collapsed,
    _maxDepth,
    showOnlyChildren,
    isSelected,
    tagTitle,
    ellipsisMark,
    children2,
    currentPath,
    currentDepth,
    toggleFolder,
    openfileLocal,
    contextMenuFunc,
    handleMouseover,
    handleOpenScroll,
    path,
    skippedTag,
    _tagInfo,
    omitTags,
    convertedTag,
    tagMark,
    curTaginfo,
    $$scope,
    slots,
    click_handler,
    click_handler_1,
    click_handler_2,
    mouseover_handler
  ];
}
var TreeItemComponent = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, {
      entry: 0,
      hoverPreview: 1,
      openfile: 2,
      expandFolder: 3,
      showMenu: 4,
      path: 20,
      skippedTag: 21,
      openScrollView: 5
    }, add_css, [-1, -1]);
  }
};
var TreeItemComponent_default = TreeItemComponent;

// TagFolderViewComponent.svelte
function add_css2(target) {
  append_styles(target, "svelte-1lyxrts", ".nav-folder.svelte-1lyxrts{padding-bottom:64px}.nav-files-container.svelte-1lyxrts{height:100%}");
}
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[15] = list[i];
  return child_ctx;
}
function create_if_block2(ctx) {
  let div1;
  let input;
  let t;
  let div0;
  let mounted;
  let dispose;
  return {
    c() {
      div1 = element("div");
      input = element("input");
      t = space();
      div0 = element("div");
      attr(input, "type", "text");
      attr(input, "spellcheck", "false");
      attr(input, "placeholder", "Type to start search...");
      attr(div0, "class", "search-input-clear-button");
      attr(div0, "aria-label", "Clear search");
      set_style(div0, "display", "none");
      attr(div1, "class", "search-input-container");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, input);
      set_input_value(input, ctx[10]);
      append(div1, t);
      append(div1, div0);
      if (!mounted) {
        dispose = listen(input, "input", ctx[14]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & 1024 && input.value !== ctx2[10]) {
        set_input_value(input, ctx2[10]);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      mounted = false;
      dispose();
    }
  };
}
function create_each_block2(ctx) {
  let treeitemcomponent;
  let current;
  treeitemcomponent = new TreeItemComponent_default({
    props: {
      entry: ctx[15],
      hoverPreview: ctx[1],
      openfile: ctx[2],
      expandFolder: ctx[3],
      showMenu: ctx[5],
      skippedTag: "",
      path: "/",
      openScrollView: ctx[9]
    }
  });
  return {
    c() {
      create_component(treeitemcomponent.$$.fragment);
    },
    m(target, anchor) {
      mount_component(treeitemcomponent, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const treeitemcomponent_changes = {};
      if (dirty & 1)
        treeitemcomponent_changes.entry = ctx2[15];
      if (dirty & 2)
        treeitemcomponent_changes.hoverPreview = ctx2[1];
      if (dirty & 4)
        treeitemcomponent_changes.openfile = ctx2[2];
      if (dirty & 8)
        treeitemcomponent_changes.expandFolder = ctx2[3];
      if (dirty & 32)
        treeitemcomponent_changes.showMenu = ctx2[5];
      if (dirty & 512)
        treeitemcomponent_changes.openScrollView = ctx2[9];
      treeitemcomponent.$set(treeitemcomponent_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(treeitemcomponent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(treeitemcomponent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(treeitemcomponent, detaching);
    }
  };
}
function create_fragment2(ctx) {
  let div5;
  let div4;
  let div0;
  let t0;
  let div1;
  let t1;
  let div2;
  let t2;
  let div3;
  let t3;
  let div11;
  let t4;
  let div10;
  let div8;
  let div6;
  let t5;
  let div7;
  let t6;
  let t7;
  let t8;
  let div9;
  let current;
  let mounted;
  let dispose;
  let if_block = ctx[11] && create_if_block2(ctx);
  let each_value = ctx[0];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block2(get_each_context2(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      div5 = element("div");
      div4 = element("div");
      div0 = element("div");
      div0.innerHTML = `<svg viewBox="0 0 100 100" class="document" width="20" height="20"><path fill="currentColor" stroke="currentColor" d="M14,4v92h72V29.2l-0.6-0.6l-24-24L60.8,4L14,4z M18,8h40v24h24v60H18L18,8z M62,10.9L79.1,28H62V10.9z"></path></svg>`;
      t0 = space();
      div1 = element("div");
      div1.innerHTML = `<svg viewBox="0 0 100 100" class="up-and-down-arrows" width="20" height="20"><path fill="currentColor" stroke="currentColor" d="M25.8,5.9c-0.1,0-0.2,0-0.3,0.1c-0.1,0-0.1,0-0.2,0.1c-0.1,0-0.1,0-0.2,0.1c-0.1,0.1-0.3,0.2-0.4,0.3 c-0.1,0.1-0.2,0.1-0.3,0.2c-0.1,0.1-0.2,0.2-0.3,0.3L8.6,22.6c-0.8,0.8-0.8,2.1,0,2.9c0.8,0.8,2.1,0.8,2.9,0L24,12.9V76 c0,0.7,0.4,1.4,1,1.8c0.6,0.4,1.4,0.4,2,0c0.6-0.4,1-1,1-1.8V12.9l12.6,12.6c0.8,0.8,2.1,0.8,2.9,0c0.8-0.8,0.8-2.1,0-2.9 L27.7,6.9c-0.1-0.2-0.3-0.4-0.6-0.6c-0.2-0.2-0.5-0.3-0.8-0.3C26.2,6,26,5.9,25.8,5.9L25.8,5.9z M74,6c-1.1,0-2,0.9-2,2s0.9,2,2,2 s2-0.9,2-2S75.1,6,74,6z M74,14c-1.1,0-2,0.9-2,2s0.9,2,2,2s2-0.9,2-2S75.1,14,74,14z M73.8,21.9c-0.1,0-0.2,0-0.3,0.1 c-0.9,0.2-1.6,1-1.6,2v63.1L59.4,74.6c-0.5-0.5-1.2-0.7-1.9-0.6c-0.8,0.1-1.4,0.7-1.6,1.4c-0.2,0.7,0,1.5,0.6,2l15.8,15.7 c0,0.1,0.1,0.1,0.1,0.2l0.1,0.1c0,0,0.1,0.1,0.1,0.1c0,0,0,0,0.1,0c0.1,0.1,0.3,0.2,0.4,0.3c0,0,0,0,0.1,0c0,0,0.1,0,0.1,0.1 c0,0,0,0,0.1,0c0.1,0,0.1,0,0.2,0.1c0.2,0,0.4,0,0.6,0c0,0,0.1,0,0.1,0c0.2,0,0.3-0.1,0.5-0.2c0.3-0.1,0.5-0.3,0.7-0.6l15.9-15.8 c0.8-0.8,0.8-2.1,0-2.9c-0.8-0.8-2.1-0.8-2.9,0L76,87.1V24c0-0.6-0.2-1.1-0.6-1.5C75,22.1,74.4,21.9,73.8,21.9L73.8,21.9z M26,82 c-1.1,0-2,0.9-2,2c0,1.1,0.9,2,2,2c1.1,0,2-0.9,2-2C28,82.9,27.1,82,26,82z M26,90c-1.1,0-2,0.9-2,2s0.9,2,2,2c1.1,0,2-0.9,2-2 C28,90.9,27.1,90,26,90z"></path></svg>`;
      t1 = space();
      div2 = element("div");
      div2.innerHTML = `<svg viewBox="0 0 100 100" class="stacked-levels" width="20" height="20"><path fill="currentColor" stroke="currentColor" d="M12,4c-1.1,0-2,0.9-2,2v20c0,1.1,0.9,2,2,2h14v21.7c0,0.2,0,0.4,0,0.7V84c0,1.1,0.9,2,2,2h26v8c0,1.1,0.9,2,2,2h32 c1.1,0,2-0.9,2-2V74c0-1.1-0.9-2-2-2H56c-1.1,0-2,0.9-2,2v8H30V52h24v8c0,1.1,0.9,2,2,2h32c1.1,0,2-0.9,2-2V40c0-1.1-0.9-2-2-2 H56c-1.1,0-2,0.9-2,2v8H30V28h14c1.1,0,2-0.9,2-2V6c0-1.1-0.9-2-2-2L12,4z M14,8h28v16H28.3c-0.1,0-0.2,0-0.3,0 c-0.1,0-0.2,0-0.3,0H14L14,8z M58,42h28v16H58v-7.7c0-0.2,0-0.4,0-0.7V42z M58,76h28v16H58v-7.7c0-0.2,0-0.4,0-0.7V76z"></path></svg>`;
      t2 = space();
      div3 = element("div");
      div3.innerHTML = `<svg viewBox="0 0 100 100" class="search" width="20" height="20"><path fill="currentColor" stroke="currentColor" stroke-width="2" d="M42,6C23.2,6,8,21.2,8,40s15.2,34,34,34c7.4,0,14.3-2.4,19.9-6.4l26.3,26.3l5.6-5.6l-26-26.1c5.1-6,8.2-13.7,8.2-22.1 C76,21.2,60.8,6,42,6z M42,10c16.6,0,30,13.4,30,30S58.6,70,42,70S12,56.6,12,40S25.4,10,42,10z"></path></svg>`;
      t3 = space();
      div11 = element("div");
      if (if_block)
        if_block.c();
      t4 = space();
      div10 = element("div");
      div8 = element("div");
      div6 = element("div");
      t5 = space();
      div7 = element("div");
      t6 = text("Tags: ");
      t7 = text(ctx[4]);
      t8 = space();
      div9 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div0, "class", "nav-action-button");
      attr(div0, "aria-label", "New note");
      attr(div1, "class", "nav-action-button");
      attr(div1, "aria-label", "Change sort order");
      attr(div2, "class", "nav-action-button");
      attr(div2, "aria-label", "Expand limit");
      attr(div3, "class", "nav-action-button");
      attr(div3, "aria-label", "Search");
      attr(div4, "class", "nav-buttons-container tagfolder-buttons-container");
      attr(div5, "class", "nav-header");
      attr(div6, "class", "nav-folder-collapse-indicator collapse-icon");
      attr(div7, "class", "nav-folder-title-content");
      attr(div8, "class", "nav-folder-title");
      attr(div9, "class", "nav-folder-children");
      attr(div10, "class", "nav-folder mod-root svelte-1lyxrts");
      attr(div11, "class", "nav-files-container svelte-1lyxrts");
    },
    m(target, anchor) {
      insert(target, div5, anchor);
      append(div5, div4);
      append(div4, div0);
      append(div4, t0);
      append(div4, div1);
      append(div4, t1);
      append(div4, div2);
      append(div4, t2);
      append(div4, div3);
      insert(target, t3, anchor);
      insert(target, div11, anchor);
      if (if_block)
        if_block.m(div11, null);
      append(div11, t4);
      append(div11, div10);
      append(div10, div8);
      append(div8, div6);
      append(div8, t5);
      append(div8, div7);
      append(div7, t6);
      append(div7, t7);
      append(div10, t8);
      append(div10, div9);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div9, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen(div0, "click", function() {
            if (is_function(ctx[8]))
              ctx[8].apply(this, arguments);
          }),
          listen(div1, "click", function() {
            if (is_function(ctx[7]))
              ctx[7].apply(this, arguments);
          }),
          listen(div2, "click", function() {
            if (is_function(ctx[6]))
              ctx[6].apply(this, arguments);
          }),
          listen(div3, "click", ctx[12])
        ];
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (ctx[11]) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block2(ctx);
          if_block.c();
          if_block.m(div11, t4);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (!current || dirty & 16)
        set_data(t7, ctx[4]);
      if (dirty & 559) {
        each_value = ctx[0];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context2(ctx, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block2(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div9, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div5);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(div11);
      if (if_block)
        if_block.d();
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance2($$self, $$props, $$invalidate) {
  let { items = [] } = $$props;
  let { hoverPreview } = $$props;
  let { openfile } = $$props;
  let { expandFolder } = $$props;
  let { vaultname = "" } = $$props;
  let { showMenu } = $$props;
  let { showLevelSelect } = $$props;
  let { showOrder } = $$props;
  let { newNote } = $$props;
  let { setSearchString } = $$props;
  let { openScrollView } = $$props;
  treeRoot.subscribe((root) => {
    var _a;
    $$invalidate(0, items = (_a = root === null || root === void 0 ? void 0 : root.children) !== null && _a !== void 0 ? _a : []);
  });
  let search = "";
  let showSearch = false;
  function toggleSearch() {
    $$invalidate(11, showSearch = !showSearch);
    if (!showSearch) {
      $$invalidate(10, search = "");
    }
  }
  function input_input_handler() {
    search = this.value;
    $$invalidate(10, search);
  }
  $$self.$$set = ($$props2) => {
    if ("items" in $$props2)
      $$invalidate(0, items = $$props2.items);
    if ("hoverPreview" in $$props2)
      $$invalidate(1, hoverPreview = $$props2.hoverPreview);
    if ("openfile" in $$props2)
      $$invalidate(2, openfile = $$props2.openfile);
    if ("expandFolder" in $$props2)
      $$invalidate(3, expandFolder = $$props2.expandFolder);
    if ("vaultname" in $$props2)
      $$invalidate(4, vaultname = $$props2.vaultname);
    if ("showMenu" in $$props2)
      $$invalidate(5, showMenu = $$props2.showMenu);
    if ("showLevelSelect" in $$props2)
      $$invalidate(6, showLevelSelect = $$props2.showLevelSelect);
    if ("showOrder" in $$props2)
      $$invalidate(7, showOrder = $$props2.showOrder);
    if ("newNote" in $$props2)
      $$invalidate(8, newNote = $$props2.newNote);
    if ("setSearchString" in $$props2)
      $$invalidate(13, setSearchString = $$props2.setSearchString);
    if ("openScrollView" in $$props2)
      $$invalidate(9, openScrollView = $$props2.openScrollView);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 9216) {
      $: {
        if (setSearchString != null) {
          setSearchString(search);
        }
      }
    }
  };
  return [
    items,
    hoverPreview,
    openfile,
    expandFolder,
    vaultname,
    showMenu,
    showLevelSelect,
    showOrder,
    newNote,
    openScrollView,
    search,
    showSearch,
    toggleSearch,
    setSearchString,
    input_input_handler
  ];
}
var TagFolderViewComponent = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance2, create_fragment2, safe_not_equal, {
      items: 0,
      hoverPreview: 1,
      openfile: 2,
      expandFolder: 3,
      vaultname: 4,
      showMenu: 5,
      showLevelSelect: 6,
      showOrder: 7,
      newNote: 8,
      setSearchString: 13,
      openScrollView: 9
    }, add_css2);
  }
};
var TagFolderViewComponent_default = TagFolderViewComponent;

// ScrollView.ts
var import_obsidian2 = __toModule(require("obsidian"));

// ScrollViewMarkdownComponent.svelte
var import_obsidian = __toModule(require("obsidian"));
function add_css3(target) {
  append_styles(target, "svelte-1qfikme", ".markdownBody.svelte-1qfikme{user-select:text;-webkit-user-select:text}");
}
function create_fragment3(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "class", "markdownBody svelte-1qfikme");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      ctx[2](div);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      ctx[2](null);
    }
  };
}
function instance3($$self, $$props, $$invalidate) {
  let { file = { path: "" } } = $$props;
  let el;
  onMount(() => {
    if (file.content && el) {
      import_obsidian.MarkdownRenderer.renderMarkdown(file.content, el, file.path, null);
    }
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(0, el), $$invalidate(1, file);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("file" in $$props2)
      $$invalidate(1, file = $$props2.file);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 3) {
      $: {
        if (file && file.content && el) {
          $$invalidate(0, el.innerHTML = "", el);
          import_obsidian.MarkdownRenderer.renderMarkdown(file.content, el, file.path, null);
        }
      }
    }
  };
  return [el, file, div_binding];
}
var ScrollViewMarkdownComponent = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance3, create_fragment3, safe_not_equal, { file: 1 }, add_css3);
  }
};
var ScrollViewMarkdownComponent_default = ScrollViewMarkdownComponent;

// ScrollViewComponent.svelte
function add_css4(target) {
  append_styles(target, "svelte-s1mg0b", ".header.svelte-s1mg0b{background-color:var(--background-secondary-alt);position:sticky;top:0;color:var(--text-normal);margin-bottom:8px}.file.svelte-s1mg0b{cursor:pointer}.path.svelte-s1mg0b{font-size:75%}hr.svelte-s1mg0b{margin:8px auto}");
}
function get_each_context3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[7] = list[i];
  return child_ctx;
}
function create_each_block3(ctx) {
  let div1;
  let div0;
  let span0;
  let t0_value = ctx[7].title + "";
  let t0;
  let t1;
  let span1;
  let t2;
  let t3_value = ctx[7].path + "";
  let t3;
  let t4;
  let t5;
  let scrollviewmarkdown;
  let t6;
  let hr;
  let t7;
  let current;
  let mounted;
  let dispose;
  scrollviewmarkdown = new ScrollViewMarkdownComponent_default({ props: { file: ctx[7] } });
  function click_handler(...args) {
    return ctx[6](ctx[7], ...args);
  }
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      span0 = element("span");
      t0 = text(t0_value);
      t1 = space();
      span1 = element("span");
      t2 = text("(");
      t3 = text(t3_value);
      t4 = text(")");
      t5 = space();
      create_component(scrollviewmarkdown.$$.fragment);
      t6 = space();
      hr = element("hr");
      t7 = space();
      attr(span1, "class", "path svelte-s1mg0b");
      attr(div0, "class", "header svelte-s1mg0b");
      attr(hr, "class", "svelte-s1mg0b");
      attr(div1, "class", "file svelte-s1mg0b");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, span0);
      append(span0, t0);
      append(div0, t1);
      append(div0, span1);
      append(span1, t2);
      append(span1, t3);
      append(span1, t4);
      append(div1, t5);
      mount_component(scrollviewmarkdown, div1, null);
      append(div1, t6);
      append(div1, hr);
      append(div1, t7);
      current = true;
      if (!mounted) {
        dispose = listen(div1, "click", click_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if ((!current || dirty & 2) && t0_value !== (t0_value = ctx[7].title + ""))
        set_data(t0, t0_value);
      if ((!current || dirty & 2) && t3_value !== (t3_value = ctx[7].path + ""))
        set_data(t3, t3_value);
      const scrollviewmarkdown_changes = {};
      if (dirty & 2)
        scrollviewmarkdown_changes.file = ctx[7];
      scrollviewmarkdown.$set(scrollviewmarkdown_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(scrollviewmarkdown.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(scrollviewmarkdown.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_component(scrollviewmarkdown);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment4(ctx) {
  let div1;
  let div0;
  let t0;
  let t1;
  let t2;
  let hr;
  let t3;
  let current;
  let each_value = ctx[1];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block3(get_each_context3(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      t0 = text("Files in ");
      t1 = text(ctx[0]);
      t2 = space();
      hr = element("hr");
      t3 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div0, "class", "header svelte-s1mg0b");
      attr(hr, "class", "svelte-s1mg0b");
      attr(div1, "class", "x");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, t0);
      append(div0, t1);
      append(div1, t2);
      append(div1, hr);
      append(div1, t3);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div1, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & 1)
        set_data(t1, ctx2[0]);
      if (dirty & 6) {
        each_value = ctx2[1];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context3(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block3(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div1, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance4($$self, $$props, $$invalidate) {
  let files;
  let tagPath;
  let { store = writable({ files: [], title: "", tagPath: "" }) } = $$props;
  let { openfile } = $$props;
  let state = { files: [], title: "", tagPath: "" };
  function handleOpenFile(e, file) {
    openfile(file.path);
    e.preventDefault();
  }
  const click_handler = (file, evt) => handleOpenFile(evt, file);
  $$self.$$set = ($$props2) => {
    if ("store" in $$props2)
      $$invalidate(3, store = $$props2.store);
    if ("openfile" in $$props2)
      $$invalidate(4, openfile = $$props2.openfile);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 8) {
      $: {
        store.subscribe((_state) => {
          $$invalidate(5, state = Object.assign({}, _state));
          return () => {
          };
        });
      }
    }
    if ($$self.$$.dirty & 32) {
      $:
        $$invalidate(1, files = state.files);
    }
    if ($$self.$$.dirty & 32) {
      $:
        $$invalidate(0, tagPath = state.tagPath.split("/").map((e) => renderSpecialTag(e)).join("/"));
    }
  };
  return [tagPath, files, handleOpenFile, store, openfile, state, click_handler];
}
var ScrollViewComponent = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance4, create_fragment4, safe_not_equal, { store: 3, openfile: 4 }, add_css4);
  }
};
var ScrollViewComponent_default = ScrollViewComponent;

// ScrollView.ts
var ScrollView = class extends import_obsidian2.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.state = { files: [], title: "", tagPath: "" };
    this.plugin = plugin;
    this.store = writable({ files: [], title: "", tagPath: "" });
  }
  getIcon() {
    return "sheets-in-box";
  }
  getViewType() {
    return VIEW_TYPE_SCROLL;
  }
  getDisplayText() {
    return this.state.tagPath || "Tags scroll";
  }
  setFile(filenames) {
    return __async(this, null, function* () {
      this.state = __spreadProps(__spreadValues({}, this.state), { files: filenames });
      yield this.updateView();
    });
  }
  setState(state, result) {
    return __async(this, null, function* () {
      this.state = __spreadValues({}, state);
      this.title = state.title;
      yield this.updateView();
      result = {};
      return;
    });
  }
  getState() {
    return this.state;
  }
  isFileOpened(path) {
    return this.state.files.some((e) => e.path == path);
  }
  getScrollViewState() {
    return this.state;
  }
  updateView() {
    return __async(this, null, function* () {
      const items = [];
      for (const item of this.state.files) {
        if (item.content) {
          items.push(item);
        } else {
          const f = this.app.vault.getAbstractFileByPath(item.path);
          if (f == null || !(f instanceof import_obsidian2.TFile)) {
            console.log(`File not found:${item.path}`);
            items.push(item);
            continue;
          }
          const title = this.plugin.getFileTitle(f);
          const w = yield this.app.vault.read(f);
          item.content = w;
          item.title = title;
          items.push(item);
        }
      }
      this.state = __spreadProps(__spreadValues({}, this.state), { files: [...items] });
      this.store.set(this.state);
    });
  }
  onOpen() {
    return __async(this, null, function* () {
      this.component = new ScrollViewComponent_default({
        target: this.contentEl,
        props: {
          store: this.store,
          openfile: this.plugin.focusFile
        }
      });
    });
  }
  onClose() {
    return __async(this, null, function* () {
      this.component.$destroy();
    });
  }
};

// main.ts
var HideItemsType = {
  NONE: "Hide nothing",
  DEDICATED_INTERMIDIATES: "Only intermediates of nested tags",
  ALL_EXCEPT_BOTTOM: "All intermediates"
};
var VIEW_TYPE_TAGFOLDER = "tagfolder-view";
var OrderKeyTag = {
  NAME: "File name",
  ITEMS: "Count of items"
};
var OrderDirection = {
  ASC: "Ascending",
  DESC: "Descending"
};
var OrderKeyItem = {
  DISPNAME: "Displaying name",
  NAME: "File name",
  MTIME: "Modified time",
  CTIME: "Created time",
  FULLPATH: "Fullpath of the file"
};
var lastSkipped = 0;
var doevents = () => {
  const n = performance.now();
  if (n - lastSkipped < 20) {
    return Promise.resolve();
  }
  return new Promise((res) => {
    window.requestAnimationFrame(() => {
      lastSkipped = performance.now();
      res();
    });
  });
};
var dotted = (object, notation) => {
  return notation.split(".").reduce((a, b) => a && b in a ? a[b] : null, object);
};
var compare = Intl && Intl.Collator ? new Intl.Collator().compare : (x, y) => `${x != null ? x : ""}`.localeCompare(`${y != null ? y : ""}`);
var TagFolderView = class extends import_obsidian3.ItemView {
  getIcon() {
    return "stacked-levels";
  }
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
    this.showMenu = this.showMenu.bind(this);
    this.showOrder = this.showOrder.bind(this);
    this.newNote = this.newNote.bind(this);
    this.showLevelSelect = this.showLevelSelect.bind(this);
  }
  newNote(evt) {
    this.app.commands.executeCommandById("file-explorer:new-file");
  }
  showOrder(evt) {
    const menu = new import_obsidian3.Menu(this.app);
    menu.addItem((item) => {
      item.setTitle("Tags").setIcon("hashtag").onClick((evt2) => __async(this, null, function* () {
        const menu2 = new import_obsidian3.Menu(this.app);
        for (const key in OrderKeyTag) {
          for (const direction in OrderDirection) {
            menu2.addItem((item2) => {
              const newSetting = `${key}_${direction}`;
              item2.setTitle(OrderKeyTag[key] + " " + OrderDirection[direction]).onClick(() => __async(this, null, function* () {
                this.plugin.settings.sortTypeTag = newSetting;
                yield this.plugin.saveSettings();
                this.plugin.setRoot(this.plugin.root);
              }));
              if (newSetting == this.plugin.settings.sortTypeTag) {
                item2.setIcon("checkmark");
              }
              menu2.showAtMouseEvent(evt);
              return item2;
            });
          }
        }
      }));
      return item;
    });
    menu.addItem((item) => {
      item.setTitle("Items").setIcon("document").onClick((evt2) => __async(this, null, function* () {
        const menu2 = new import_obsidian3.Menu(this.app);
        for (const key in OrderKeyItem) {
          for (const direction in OrderDirection) {
            menu2.addItem((item2) => {
              const newSetting = `${key}_${direction}`;
              item2.setTitle(OrderKeyItem[key] + " " + OrderDirection[direction]).onClick(() => __async(this, null, function* () {
                this.plugin.settings.sortType = newSetting;
                yield this.plugin.saveSettings();
                this.plugin.setRoot(this.plugin.root);
              }));
              if (newSetting == this.plugin.settings.sortType) {
                item2.setIcon("checkmark");
              }
              menu2.showAtMouseEvent(evt);
              return item2;
            });
          }
        }
      }));
      return item;
    });
    menu.showAtMouseEvent(evt);
  }
  showLevelSelect(evt) {
    const menu = new import_obsidian3.Menu(this.app);
    const setLevel = (level) => __async(this, null, function* () {
      this.plugin.settings.expandLimit = level;
      yield this.plugin.saveSettings();
      maxDepth.set(level);
      this.plugin.setRoot(this.plugin.root);
    });
    for (const level of [2, 3, 4, 5]) {
      menu.addItem((item) => {
        item.setTitle(`Level ${level - 1}`).onClick(() => {
          setLevel(level);
        });
        if (this.plugin.settings.expandLimit == level)
          item.setIcon("checkmark");
        return item;
      });
    }
    menu.addItem((item) => {
      item.setTitle("No limit").onClick(() => {
        setLevel(0);
      });
      if (this.plugin.settings.expandLimit == 0)
        item.setIcon("checkmark");
      return item;
    });
    menu.showAtMouseEvent(evt);
  }
  getViewType() {
    return VIEW_TYPE_TAGFOLDER;
  }
  getDisplayText() {
    return "Tag Folder";
  }
  onOpen() {
    return __async(this, null, function* () {
      this.component = new TagFolderViewComponent_default({
        target: this.contentEl,
        props: {
          openfile: this.plugin.focusFile,
          hoverPreview: this.plugin.hoverPreview,
          expandFolder: this.plugin.expandFolder,
          vaultname: this.app.vault.getName(),
          showMenu: this.showMenu,
          showLevelSelect: this.showLevelSelect,
          showOrder: this.showOrder,
          newNote: this.newNote,
          setSearchString: this.plugin.setSearchString,
          openScrollView: this.plugin.openScrollView
        }
      });
    });
  }
  onClose() {
    return __async(this, null, function* () {
      this.component.$destroy();
    });
  }
  setTreeRoot(root) {
    treeRoot.set(root);
  }
  showMenu(evt, path, entry) {
    const x = path.replace(SUBTREE_MARK_REGEX, "###");
    const expandedTags = x.split("/").filter((e) => e.trim() != "").filter((e) => !isSpecialTag(e)).map((e) => e.replace(/###/g, "/")).map((e) => e.split("/").map((ee) => renderSpecialTag(ee)).join("/")).map((e) => "#" + e).join(" ").trim();
    const menu = new import_obsidian3.Menu(this.app);
    if (navigator && navigator.clipboard) {
      menu.addItem((item) => item.setTitle(`Copy tags:${expandedTags}`).setIcon("hashtag").onClick(() => __async(this, null, function* () {
        yield navigator.clipboard.writeText(expandedTags);
        new import_obsidian3.Notice("Copied");
      })));
    }
    if ("tag" in entry) {
      if (this.plugin.settings.useTagInfo && this.plugin.tagInfo != null) {
        const tag = entry.ancestors[entry.ancestors.length - 1];
        if (tag in this.plugin.tagInfo && this.plugin.tagInfo[tag]) {
          menu.addItem((item) => item.setTitle(`Unpin`).setIcon("pin").onClick(() => __async(this, null, function* () {
            this.plugin.tagInfo = __spreadProps(__spreadValues({}, this.plugin.tagInfo), {
              [tag]: void 0
            });
            this.plugin.applyTagInfo();
            yield this.plugin.saveTagInfo();
          })));
        } else {
          menu.addItem((item) => {
            item.setTitle(`Pin`).setIcon("pin").onClick(() => __async(this, null, function* () {
              this.plugin.tagInfo = __spreadProps(__spreadValues({}, this.plugin.tagInfo), {
                [tag]: { key: "" }
              });
              this.plugin.applyTagInfo();
              yield this.plugin.saveTagInfo();
            }));
          });
        }
        menu.addItem((item) => {
          item.setTitle(`Open scroll view`).setIcon("sheets-in-box").onClick(() => __async(this, null, function* () {
            const files = entry.allDescendants.map((e) => e.path);
            const tagPath = entry.ancestors.join("/");
            yield this.plugin.openScrollView(null, expandedTags, tagPath, files);
          }));
        });
      }
    }
    if ("path" in entry) {
      const path2 = entry.path;
      const file = this.app.vault.getAbstractFileByPath(path2);
      this.app.workspace.trigger("file-menu", menu, file, "file-explorer");
    }
    if ("screenX" in evt) {
      menu.showAtPosition({ x: evt.pageX, y: evt.pageY });
    } else {
      menu.showAtPosition({
        x: evt.nativeEvent.locationX,
        y: evt.nativeEvent.locationY
      });
    }
  }
};
var rippleDirty = (entry) => {
  for (const child of entry.children) {
    if ("tag" in child) {
      if (rippleDirty(child)) {
        entry.descendants = null;
        entry.allDescendants = null;
        entry.descendantsMemo = null;
      }
    }
  }
  if (entry.descendants == null)
    return true;
};
var retrieveAllDescendants = (entry) => {
  return ("tag" in entry ? entry.children.map((e) => "tag" in e ? [...e.descendants, ...retrieveAllDescendants(e)] : [e]) : [entry]).flat();
};
var retrieveChildren = (entry) => {
  return ("tag" in entry ? entry.children.map((e) => "tag" in e ? [...retrieveChildren(e)] : [e]) : [entry]).flat();
};
var expandDescendants = (entry, hideItems) => {
  const ret = [];
  for (const v of entry.children) {
    if ("tag" in v) {
      if (v.descendants == null) {
        const w = expandDescendants(v, hideItems).filter((e) => !ret.contains(e));
        ret.push(...w);
      } else {
        const w = v.descendants.filter((e) => !ret.contains(e));
        ret.push(...w);
      }
    } else {
      if (!ret.contains(v))
        ret.push(v);
    }
  }
  const leafs = entry.descendantsMemo != null ? entry.descendantsMemo : entry.descendantsMemo = entry.children.map((e) => "tag" in e ? e.children.map((ee) => retrieveAllDescendants(ee).flat()).flat() : []).flat();
  if (hideItems == "DEDICATED_INTERMIDIATES" && entry.isDedicatedTree || hideItems == "ALL_EXCEPT_BOTTOM") {
    entry.descendants = ret.filter((e) => !leafs.contains(e));
  } else {
    entry.descendants = ret;
  }
  entry.allDescendants = ret;
  entry.itemsCount = new Set([...ret, ...leafs]).size;
  return ret;
};
var expandTree = (node, reduceNestedParent) => __async(void 0, null, function* () {
  let modified = false;
  const tree = node.children;
  const ancestor = [...node.ancestors];
  const tags = Array.from(new Set(node.children.filter((e) => "tags" in e).map((e) => e.tags).flat()));
  const ancestorAsTags = ancestorToTags(ancestor);
  for (const tag of tags) {
    if (ancestorAsTags.map((e) => e.toLocaleLowerCase()).contains(tag.toLocaleLowerCase()))
      continue;
    const newChildren = node.children.filter((e) => "tags" in e && e.tags.map((e2) => e2.toLocaleLowerCase()).contains(tag.toLocaleLowerCase()));
    if (tree.find((e) => "tag" in e && e.tag.toLocaleLowerCase() == tag.toLocaleLowerCase())) {
      continue;
    }
    const newLeaf = {
      tag,
      children: newChildren,
      ancestors: [...new Set([...ancestor, tag])],
      descendants: null,
      isDedicatedTree: false,
      itemsCount: newChildren.length,
      allDescendants: null
    };
    tree.push(newLeaf);
  }
  modified = (yield splitTag(node, reduceNestedParent)) || modified;
  if (modified) {
    yield expandTree(node, reduceNestedParent);
  }
  return modified;
});
var splitTag = (entry, reduceNestedParent, root) => __async(void 0, null, function* () {
  let modified = false;
  const xRoot = root || entry;
  yield doevents();
  entry.children = entry.children.sort((a, b) => {
    if ("tag" in a && "tag" in b) {
      return a.tag.split("/").length - b.tag.split("/").length;
    } else {
      return 0;
    }
  });
  for (const curEntry of entry.children) {
    if ("tag" in curEntry) {
      modified = (yield splitTag(curEntry, reduceNestedParent, xRoot)) || modified;
      if (curEntry.tag.contains("/")) {
        const tempEntry = curEntry;
        entry.children.remove(tempEntry);
        const tagsArray = tempEntry.tag.split("/");
        const tagCar = tagsArray.shift();
        const tagCdr = SUBTREE_MARK + tagsArray.join("/");
        const ancestors = curEntry.ancestors.map((e) => e.toLocaleLowerCase());
        const newAncestorsBase = tempEntry.ancestors.filter((e) => e != tempEntry.tag);
        const idxCar = ancestors.indexOf(tagCar.toLocaleLowerCase());
        const idxCdr = ancestors.indexOf(tagCdr.toLocaleLowerCase());
        if (idxCar != -1) {
          if (idxCar < idxCdr) {
            modified = true;
            continue;
          } else {
            if (reduceNestedParent) {
              modified = true;
              const replacer = __spreadProps(__spreadValues({}, tempEntry), {
                tag: tagCdr,
                ancestors: [
                  ...newAncestorsBase,
                  tagCar,
                  tagCdr
                ],
                itemsCount: 0,
                descendants: null,
                allDescendants: null,
                isDedicatedTree: tempEntry.isDedicatedTree
              });
              const old = entry.children.find((e) => "tag" in e && e.tag == tagCdr);
              if (old) {
                entry.children.remove(old);
                replacer.children = [...replacer.children, ...old.children];
              }
              entry.children.push(replacer);
              continue;
            }
          }
        }
        const parent = entry.children.find((e) => "tag" in e && e.tag.toLocaleLowerCase() == tagCar.toLocaleLowerCase());
        const tempChildren = tempEntry.children;
        if (!parent) {
          const newGrandchild = {
            tag: tagCdr,
            children: [...tempChildren],
            ancestors: [
              ...newAncestorsBase,
              tagCar,
              tagCdr
            ],
            itemsCount: 0,
            descendants: null,
            allDescendants: null,
            isDedicatedTree: false
          };
          const newChild = {
            tag: tagCar,
            children: [newGrandchild],
            ancestors: [...new Set([...newAncestorsBase, tagCar])],
            descendants: null,
            allDescendants: null,
            isDedicatedTree: true,
            itemsCount: 0
          };
          newChild.children = [newGrandchild];
          entry.children.push(newChild);
          yield splitTag(entry, reduceNestedParent, xRoot);
          modified = true;
        } else {
          const oldIx = parent.children.find((e) => "tag" in e && e.tag.toLocaleLowerCase() == tagCdr.toLocaleLowerCase());
          if (oldIx != null) {
            oldIx.children.push(...tempChildren.filter((e) => !oldIx.children.contains(e)));
            yield splitTag(oldIx, reduceNestedParent, xRoot);
          } else {
            const x = {
              tag: tagCdr,
              children: [...tempChildren],
              ancestors: [
                ...newAncestorsBase,
                tagCar,
                tagCdr
              ],
              descendants: null,
              allDescendants: null,
              isDedicatedTree: false,
              itemsCount: 0
            };
            parent.children.push(x);
            if (!parent.isDedicatedTree) {
              const p = retrieveChildren(parent).map((e) => e.path);
              const c = retrieveChildren(tempEntry).map((e) => e.path);
              if (c.some((entry2) => !p.contains(entry2))) {
                parent.isDedicatedTree = false;
              } else {
                parent.isDedicatedTree = true;
              }
            }
            yield splitTag(parent, reduceNestedParent, xRoot);
          }
          modified = true;
        }
      }
    }
  }
  if (modified) {
    modified = yield splitTag(entry, reduceNestedParent, xRoot);
  }
  if (modified) {
    if (entry.isDedicatedTree && entry.children.some((e) => "tags" in e)) {
      entry.isDedicatedTree = false;
    }
  }
  return modified;
});
function getTagName(tagName, tagInfo2, invert) {
  if (tagInfo2 == null)
    return tagName;
  const prefix = invert == -1 ? `\uFFFF` : ``;
  const unpinned = invert == 1 ? `\uFFFF` : ``;
  if (tagName in tagInfo2 && tagInfo2[tagName]) {
    if ("key" in tagInfo2[tagName]) {
      const k = `${prefix}_-${tagInfo2[tagName].key}__${tagName}`;
      return k;
    }
  }
  return `${prefix}_${unpinned}_${tagName}`;
}
function getCompareMethodTags(settings) {
  const invert = settings.sortTypeTag.contains("_DESC") ? -1 : 1;
  switch (settings.sortTypeTag) {
    case "ITEMS_ASC":
    case "ITEMS_DESC":
      return (a, b, tagInfo2) => (a.itemsCount - b.itemsCount) * invert;
    case "NAME_ASC":
    case "NAME_DESC":
      return (a, b, tagInfo2) => compare(getTagName(a.tag, settings.useTagInfo ? tagInfo2 : null, invert), getTagName(b.tag, settings.useTagInfo ? tagInfo2 : null, invert)) * invert;
    default:
      console.warn("Compare method (tags) corrupted");
      return (a, b, tagInfo2) => compare(a.tag, b.tag) * invert;
  }
}
function getCompareMethodItems(settings) {
  const invert = settings.sortType.contains("_DESC") ? -1 : 1;
  switch (settings.sortType) {
    case "DISPNAME_ASC":
    case "DISPNAME_DESC":
      return (a, b) => compare(a.displayName, b.displayName) * invert;
    case "FULLPATH_ASC":
    case "FULLPATH_DESC":
      return (a, b) => compare(a.path, b.path) * invert;
    case "MTIME_ASC":
    case "MTIME_DESC":
      return (a, b) => (a.mtime - b.mtime) * invert;
    case "CTIME_ASC":
    case "CTIME_DESC":
      return (a, b) => (a.ctime - b.ctime) * invert;
    case "NAME_ASC":
    case "NAME_DESC":
      return (a, b) => compare(a.filename, b.filename) * invert;
    default:
      console.warn("Compare method (items) corrupted");
      return (a, b) => compare(a.displayName, b.displayName) * invert;
  }
}
var TagFolderPlugin = class extends import_obsidian3.Plugin {
  constructor() {
    super(...arguments);
    this.expandedFolders = ["root"];
    this.currentOpeningFile = "";
    this.searchString = "";
    this.focusFile = (path) => {
      const targetFile = this.app.vault.getFiles().find((f) => f.path === path);
      if (targetFile) {
        const leaf = this.app.workspace.getLeaf(false);
        leaf.openFile(targetFile);
      }
    };
    this.expandingProcs = 0;
    this.expandFolder = (entry, expanded) => __async(this, null, function* () {
      if ("tag" in entry) {
        const key = [...entry.ancestors].join("/");
        if (expanded) {
          this.expandedFolders = Array.from(new Set([...this.expandedFolders, key]));
          this.expandedFolders = this.expandedFolders.sort((a, b) => a.split("/").length - b.split("/").length);
        } else {
          this.expandedFolders = this.expandedFolders.filter((e) => e != key);
        }
        yield this.expandLastExpandedFolders(entry);
        this.setRoot(this.root);
      }
    });
    this.fileCaches = [];
    this.oldFileCache = "";
    this.lastTags = "";
    this.lastSettings = "";
    this.lastSearchString = "";
    this.tagInfo = null;
    this.tagInfoFrontMatterBuffer = {};
    this.tagInfoBody = "";
  }
  getView() {
    for (const leaf of this.app.workspace.getLeavesOfType(VIEW_TYPE_TAGFOLDER)) {
      const view = leaf.view;
      if (view instanceof TagFolderView) {
        return view;
      }
    }
    return null;
  }
  hoverPreview(e, path) {
    this.app.workspace.trigger("hover-link", {
      event: e,
      source: "file-explorer",
      hoverParent: this,
      targetEl: e.target,
      linktext: path
    });
  }
  setSearchString(search) {
    this.searchString = search;
    this.refreshAllTree(null);
  }
  expandLastExpandedFolders(_0, _1) {
    return __async(this, arguments, function* (entry, force, path = [], openedTags = {}, maxDepth2 = 1) {
      if (maxDepth2 < 0) {
        return;
      }
      if ("tag" in entry) {
        if (path.indexOf(entry.tag) !== -1)
          return;
        if (omittedTags(entry))
          return;
        const key = entry.ancestors.join("/");
        for (const tags of this.expandedFolders) {
          const tagPrefixToOpen = [];
          const tagArray = tags.split("/");
          for (const f of tagArray) {
            tagPrefixToOpen.push(f);
            const tagPrefix = tagPrefixToOpen.join("/");
            if (!(tagPrefix in openedTags)) {
              openedTags[tagPrefix] = new Set();
            }
            if (openedTags[tagPrefix].has(key)) {
              continue;
            }
            if (key.startsWith(tagPrefix) || force) {
              openedTags[tagPrefix].add(key);
              yield expandTree(entry, this.settings.reduceNestedParent);
              yield splitTag(entry, this.settings.reduceNestedParent);
              for (const child of entry.children) {
                if ("tag" in child) {
                  const autoExp = isAutoExpandTree(child);
                  const nextDepth = autoExp ? maxDepth2 : maxDepth2 - 1;
                  if (path.indexOf(child.tag) == -1) {
                    yield this.expandLastExpandedFolders(child, false, [...path, entry.tag], openedTags, nextDepth);
                  }
                }
              }
            }
          }
        }
      }
    });
  }
  getFileTitle(file) {
    if (!this.settings.useTitle)
      return file.basename;
    const metadata = this.app.metadataCache.getCache(file.path);
    if (metadata.frontmatter && this.settings.frontmatterKey) {
      const d = dotted(metadata.frontmatter, this.settings.frontmatterKey);
      if (d)
        return d;
    }
    if (metadata.headings) {
      const h1 = metadata.headings.find((e) => e.level == 1);
      if (h1) {
        return h1.heading;
      }
    }
    return file.basename;
  }
  getDisplayName(file) {
    const filename = this.getFileTitle(file) || file.basename;
    if (this.settings.displayMethod == "NAME") {
      return filename;
    }
    const path = file.path.split("/");
    path.pop();
    const displayPath = path.join("/");
    if (this.settings.displayMethod == "NAME : PATH") {
      return `${filename} : ${displayPath}`;
    }
    if (this.settings.displayMethod == "PATH/NAME") {
      return `${displayPath}/${filename}`;
    }
    return filename;
  }
  onload() {
    return __async(this, null, function* () {
      yield this.loadSettings();
      this.hoverPreview = this.hoverPreview.bind(this);
      this.sortChildren = this.sortChildren.bind(this);
      this.modifyFile = this.modifyFile.bind(this);
      this.setSearchString = this.setSearchString.bind(this);
      this.openScrollView = this.openScrollView.bind(this);
      this.loadFileInfo = (0, import_obsidian3.debounce)(this.loadFileInfo.bind(this), this.settings.scanDelay, true);
      this.registerView(VIEW_TYPE_TAGFOLDER, (leaf) => new TagFolderView(leaf, this));
      this.registerView(VIEW_TYPE_SCROLL, (leaf) => new ScrollView(leaf, this));
      this.app.workspace.onLayoutReady(() => __async(this, null, function* () {
        if (this.settings.alwaysOpen) {
          this.activateView();
        }
      }));
      this.addCommand({
        id: "tagfolder-open",
        name: "Show Tag Folder",
        callback: () => {
          this.activateView();
        }
      });
      this.metadataCacheChanged = this.metadataCacheChanged.bind(this);
      this.watchWorkspaceOpen = this.watchWorkspaceOpen.bind(this);
      this.registerEvent(this.app.metadataCache.on("changed", this.metadataCacheChanged));
      this.refreshAllTree = this.refreshAllTree.bind(this);
      this.registerEvent(this.app.vault.on("rename", this.refreshAllTree));
      this.registerEvent(this.app.vault.on("delete", this.refreshAllTree));
      this.registerEvent(this.app.vault.on("modify", this.modifyFile));
      this.registerEvent(this.app.workspace.on("file-open", this.watchWorkspaceOpen));
      this.watchWorkspaceOpen(this.app.workspace.getActiveFile());
      this.addSettingTab(new TagFolderSettingTab(this.app, this));
      maxDepth.set(this.settings.expandLimit);
      if (this.settings.useTagInfo) {
        this.app.workspace.onLayoutReady(() => __async(this, null, function* () {
          yield this.loadTagInfo();
        }));
      }
    });
  }
  watchWorkspaceOpen(file) {
    if (file) {
      this.currentOpeningFile = file.path;
    } else {
      this.currentOpeningFile = "";
    }
    currentFile.set(this.currentOpeningFile);
  }
  metadataCacheChanged(file) {
    this.loadFileInfo(file);
  }
  refreshAllTree(file) {
    this.loadFileInfo();
  }
  sortChildren(a, b) {
    if ("tag" in a && !("tag" in b)) {
      return -1;
    } else if (!("tag" in a) && "tag" in b) {
      return 1;
    } else {
      if ("tag" in a && "tag" in b) {
        return this.compareTags(a, b, this.tagInfo);
      } else if ("tags" in a && "tags" in b) {
        return this.compareItems(a, b);
      } else {
        return 0;
      }
    }
  }
  sortTree(entry) {
    entry.children = entry.children.sort(this.sortChildren);
    for (const child of entry.children) {
      if ("tag" in child) {
        this.sortTree(child);
      }
    }
    entry.descendants = entry.descendants.sort(this.sortChildren);
  }
  snipEmpty(root) {
    for (const v of root.children) {
      if ("tag" in v)
        this.snipEmpty(v);
    }
    root.children = root.children.filter((e) => !("tag" in e && e.children.length == 0));
  }
  mergeRedundantCombination(root) {
    const existentChild = {};
    const removeChildren = [];
    for (const entry of root.children) {
      if (!("tag" in entry))
        continue;
      if ("tag" in entry)
        this.mergeRedundantCombination(entry);
    }
    for (const entry of root.children) {
      if (!("tag" in entry))
        continue;
      const tags = [...new Set(retrieveAllDescendants(entry))].map((e) => e.path).sort().join("-");
      if (tags in existentChild) {
        removeChildren.push(entry);
      } else {
        existentChild[tags] = entry;
      }
    }
    for (const v of removeChildren) {
      root.children.remove(v);
    }
    root.children = [...root.children];
  }
  setRoot(root) {
    var _a;
    rippleDirty(root);
    expandDescendants(root, this.settings.hideItems);
    this.snipEmpty(root);
    this.sortTree(root);
    if (this.settings.mergeRedundantCombination)
      this.mergeRedundantCombination(root);
    this.root = root;
    (_a = this.getView()) == null ? void 0 : _a.setTreeRoot(root);
  }
  updateFileCaches(diff) {
    if (this.fileCaches.length == 0 || !diff) {
      const files = this.app.vault.getMarkdownFiles();
      this.fileCaches = files.map((fileEntry) => {
        return {
          file: fileEntry,
          metadata: this.app.metadataCache.getFileCache(fileEntry)
        };
      });
    } else {
      this.fileCaches = this.fileCaches.filter((fileCache) => fileCache.file.path != diff.path);
      this.fileCaches.push({
        file: diff,
        metadata: this.app.metadataCache.getFileCache(diff)
      });
    }
    const fileCacheDump = JSON.stringify(this.fileCaches.map((e) => {
      var _a, _b;
      return {
        path: e.file.path,
        tags: ((_b = (_a = e.metadata) == null ? void 0 : _a.tags) != null ? _b : []).map((e2) => e2.tag)
      };
    }));
    if (this.oldFileCache == fileCacheDump) {
      return false;
    } else {
      this.oldFileCache = fileCacheDump;
      return true;
    }
  }
  getItemsList() {
    return __async(this, null, function* () {
      var _a;
      const items = [];
      const ignoreDocTags = this.settings.ignoreDocTags.toLocaleLowerCase().replace(/\n| /g, "").split(",");
      const ignoreTags = this.settings.ignoreTags.toLocaleLowerCase().replace(/\n| /g, "").split(",");
      const ignoreFolders = this.settings.ignoreFolders.toLocaleLowerCase().replace(/\n/g, "").split(",").map((e) => e.trim()).filter((e) => !!e);
      const searchItems = this.searchString.toLocaleLowerCase().split("|").map((ee) => ee.split(" ").map((e) => e.trim()));
      const today = Date.now();
      for (const fileCache of this.fileCaches) {
        if (ignoreFolders.find((e) => e != "" && fileCache.file.path.toLocaleLowerCase().startsWith(e))) {
          continue;
        }
        yield doevents();
        const allTagsDocs = [...new Set((_a = (0, import_obsidian3.getAllTags)(fileCache.metadata)) != null ? _a : [])];
        let allTags2 = allTagsDocs.map((e) => e.substring(1));
        if (this.settings.disableNestedTags) {
          allTags2 = allTags2.map((e) => e.split("/")).flat();
        }
        if (allTags2.length == 0) {
          allTags2 = ["_untagged"];
        }
        if (this.settings.useVirtualTag) {
          const mtime = fileCache.file.stat.mtime;
          const diff = today - mtime;
          const disp = secondsToFreshness(diff);
          allTags2.push(`_VIRTUAL_TAG_FRESHNESS/${disp}`);
        }
        if (allTags2.some((tag) => ignoreDocTags.contains(tag.toLocaleLowerCase()))) {
          continue;
        }
        const w = searchItems.map((searchItem) => {
          let bx = false;
          for (const search of searchItem) {
            if (search.startsWith("-")) {
              bx = bx || allTags2.some((tag) => tag.toLocaleLowerCase().contains(search.substring(1)));
              if (bx)
                continue;
            } else {
              bx = bx || allTags2.every((tag) => !tag.toLocaleLowerCase().contains(search));
              if (bx)
                continue;
            }
          }
          return bx;
        });
        if (w.every((e) => e))
          continue;
        allTags2 = allTags2.filter((tag) => !ignoreTags.contains(tag.toLocaleLowerCase()));
        items.push({
          tags: allTags2,
          path: fileCache.file.path,
          displayName: this.getDisplayName(fileCache.file),
          ancestors: [],
          mtime: fileCache.file.stat.mtime,
          ctime: fileCache.file.stat.ctime,
          filename: fileCache.file.basename
        });
      }
      return items;
    });
  }
  buildUpTree(items) {
    return __async(this, null, function* () {
      const root = {
        tag: "root",
        children: [...items],
        ancestors: ["root"],
        descendants: null,
        allDescendants: null,
        itemsCount: 0,
        isDedicatedTree: false
      };
      yield expandTree(root, this.settings.reduceNestedParent);
      root.children = root.children.filter((e) => "tag" in e);
      yield splitTag(root, this.settings.reduceNestedParent);
      yield this.expandLastExpandedFolders(root, true);
      return root;
    });
  }
  loadFileInfo(diff) {
    this.loadFileInfoAsync(diff);
  }
  loadFileInfoAsync(diff) {
    return __async(this, null, function* () {
      if (this.getView() == null)
        return;
      const strSetting = JSON.stringify(this.settings);
      const isSettingChanged = strSetting != this.lastSettings;
      const isSearchStringModified = this.searchString != this.lastSearchString;
      if (isSettingChanged) {
        this.lastSettings = strSetting;
      }
      if (isSearchStringModified) {
        this.lastSearchString = this.searchString;
      }
      if (!this.updateFileCaches(diff) && !isSearchStringModified && !isSettingChanged) {
        yield this.applyUpdateIntoScroll(diff);
        return;
      }
      const items = yield this.getItemsList();
      const root = yield this.buildUpTree(items);
      this.setRoot(root);
      yield this.applyUpdateIntoScroll(diff);
    });
  }
  onunload() {
    this.app.workspace.detachLeavesOfType(VIEW_TYPE_TAGFOLDER);
    this.app.workspace.detachLeavesOfType(VIEW_TYPE_SCROLL);
  }
  openScrollView(leaf, title, tagPath, files) {
    return __async(this, null, function* () {
      if (!leaf) {
        leaf = this.app.workspace.createLeafInParent(this.app.workspace.rootSplit, 1);
      }
      yield leaf.setViewState({
        type: VIEW_TYPE_SCROLL,
        active: true,
        state: { files: files.map((e) => ({ path: e })), title, tagPath }
      });
      this.app.workspace.revealLeaf(leaf);
    });
  }
  findTreeItemFromPath(tagPath, root) {
    if (!root) {
      root = this.root;
    }
    if (root.children.some((e) => !("tag" in e))) {
      return root;
    }
    const paths = tagPath.split("/");
    paths.shift();
    const path = [];
    while (paths.length > 0) {
      path.push(paths.shift());
      const child = root.children.find((e) => "tag" in e && e.tag == path.join("/"));
      if (child) {
        return this.findTreeItemFromPath(paths.join("/"), child);
      }
    }
    return null;
  }
  applyUpdateIntoScroll(file) {
    return __async(this, null, function* () {
      const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_SCROLL);
      for (const leaf of leaves) {
        const view = leaf.view;
        const viewStat = __spreadProps(__spreadValues({}, leaf.getViewState()), { state: __spreadValues({}, view.getScrollViewState()) });
        if (file && view.isFileOpened(file.path)) {
          const newStat = __spreadProps(__spreadValues({}, viewStat), {
            state: __spreadProps(__spreadValues({}, viewStat.state), {
              files: viewStat.state.files.map((e) => e.path == file.path ? {
                path: file.path
              } : e)
            })
          });
          leaf.setViewState(newStat);
        }
        const openedNode = this.findTreeItemFromPath(viewStat.state.tagPath);
        if (openedNode) {
          const newFilesArray = openedNode.allDescendants.map((e) => e.path);
          const newFiles = newFilesArray.sort().join("-");
          const oldFiles = viewStat.state.files.map((e) => e.path).sort().join("-");
          if (newFiles != oldFiles) {
            const newStat = __spreadProps(__spreadValues({}, viewStat), {
              state: __spreadProps(__spreadValues({}, viewStat.state), {
                files: newFilesArray.map((path) => {
                  const old = viewStat.state.files.find((e) => e.path == path);
                  if (old)
                    return old;
                  return {
                    path
                  };
                })
              })
            });
            leaf.setViewState(newStat);
          }
        }
      }
    });
  }
  activateView() {
    return __async(this, null, function* () {
      this.loadFileInfo();
      this.app.workspace.detachLeavesOfType(VIEW_TYPE_TAGFOLDER);
      yield this.app.workspace.getLeftLeaf(false).setViewState({
        type: VIEW_TYPE_TAGFOLDER,
        active: true
      });
      this.app.workspace.revealLeaf(this.app.workspace.getLeavesOfType(VIEW_TYPE_TAGFOLDER)[0]);
    });
  }
  modifyFile(file) {
    return __async(this, null, function* () {
      if (!this.settings.useTagInfo)
        return;
      if (this.skipOnce) {
        this.skipOnce = false;
        return;
      }
      if (file.name == this.getTagInfoFilename()) {
        yield this.loadTagInfo();
      }
    });
  }
  getTagInfoFilename() {
    return (0, import_obsidian3.normalizePath)(this.settings.tagInfo);
  }
  getTagInfoFile() {
    const file = this.app.vault.getAbstractFileByPath(this.getTagInfoFilename());
    if (file instanceof import_obsidian3.TFile) {
      return file;
    }
    return null;
  }
  applyTagInfo() {
    if (this.tagInfo == null)
      return;
    if (!this.settings.useTagInfo)
      return;
    tagInfo.set(this.tagInfo);
    setTimeout(() => {
      if (this.root)
        this.setRoot(this.root);
    }, 10);
  }
  loadTagInfo() {
    return __async(this, null, function* () {
      var _a;
      if (!this.settings.useTagInfo)
        return;
      if (this.tagInfo == null)
        this.tagInfo = {};
      const file = this.getTagInfoFile();
      if (file == null)
        return;
      const data = yield this.app.vault.read(file);
      try {
        const bodyStartIndex = data.indexOf("\n---");
        if (!data.startsWith("---") || bodyStartIndex === -1) {
          return;
        }
        const yaml = data.substring(3, bodyStartIndex);
        const yamlData = (0, import_obsidian3.parseYaml)(yaml);
        const keys = Object.keys(yamlData);
        const body = data.substring(bodyStartIndex + 5);
        this.tagInfoBody = body;
        this.tagInfoFrontMatterBuffer = yamlData;
        const newTagInfo = {};
        for (const key of keys) {
          const w = yamlData[key];
          if (!w)
            continue;
          if (typeof w != "object")
            continue;
          if (!("key" in w))
            continue;
          const eachTag = {
            key: w.key,
            mark: (_a = w.mark) != null ? _a : void 0
          };
          newTagInfo[key] = eachTag;
        }
        this.tagInfo = newTagInfo;
        this.applyTagInfo();
      } catch (ex) {
        console.log(ex);
      }
    });
  }
  saveTagInfo() {
    return __async(this, null, function* () {
      if (!this.settings.useTagInfo)
        return;
      if (this.tagInfo == null)
        return;
      const file = this.getTagInfoFile();
      const yaml = (0, import_obsidian3.stringifyYaml)(__spreadValues(__spreadValues({}, this.tagInfoFrontMatterBuffer), this.tagInfo));
      const w = `---
${yaml}---
${this.tagInfoBody}`;
      this.skipOnce = true;
      if (file == null) {
        this.app.vault.create(this.getTagInfoFilename(), w);
      } else {
        this.app.vault.modify(file, w);
      }
    });
  }
  loadSettings() {
    return __async(this, null, function* () {
      this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
      yield this.loadTagInfo();
      this.compareItems = getCompareMethodItems(this.settings);
      this.compareTags = getCompareMethodTags(this.settings);
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.settings);
      yield this.saveTagInfo();
      this.compareItems = getCompareMethodItems(this.settings);
      this.compareTags = getCompareMethodTags(this.settings);
    });
  }
};
var TagFolderSettingTab = class extends import_obsidian3.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  hide() {
    this.plugin.loadFileInfo();
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Settings for Tag Folder." });
    new import_obsidian3.Setting(containerEl).setName("Always Open").setDesc("Open Tag Folder when obsidian has been launched").addToggle((toggle) => toggle.setValue(this.plugin.settings.alwaysOpen).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.alwaysOpen = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian3.Setting(containerEl).setName("Display method").setDesc("Filename display").addDropdown((dropdown) => dropdown.addOptions({
      "PATH/NAME": "PATH/NAME",
      NAME: "NAME",
      "NAME : PATH": "NAME : PATH"
    }).setValue(this.plugin.settings.displayMethod).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.displayMethod = value;
      this.plugin.loadFileInfo(null);
      yield this.plugin.saveSettings();
    })));
    new import_obsidian3.Setting(containerEl).setName("Use title").setDesc("Use value in the frontmatter or first level one heading for `NAME`.").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.useTitle).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.useTitle = value;
        yield this.plugin.saveSettings();
      }));
    });
    new import_obsidian3.Setting(containerEl).setName("Frontmatter path").addText((text2) => {
      text2.setValue(this.plugin.settings.frontmatterKey).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.frontmatterKey = value;
        yield this.plugin.saveSettings();
      }));
    });
    new import_obsidian3.Setting(containerEl).setName("Use pinning").setDesc("When this feature is enabled, the pin information is saved in the file set in the next configuration.").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.useTagInfo).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.useTagInfo = value;
        if (this.plugin.settings.useTagInfo) {
          yield this.plugin.loadTagInfo();
        }
        yield this.plugin.saveSettings();
      }));
    });
    new import_obsidian3.Setting(containerEl).setName("Pin information file").addText((text2) => {
      text2.setValue(this.plugin.settings.tagInfo).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.tagInfo = value;
        if (this.plugin.settings.useTagInfo) {
          yield this.plugin.loadTagInfo();
        }
        yield this.plugin.saveSettings();
      }));
    });
    new import_obsidian3.Setting(containerEl).setName("Merge redundant combinations").setDesc("When this feature is enabled, a/b and b/a are merged into a/b if there is no intermediates.").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.mergeRedundantCombination).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.mergeRedundantCombination = value;
        yield this.plugin.saveSettings();
      }));
    });
    const setOrderMethod = (key, order) => __async(this, null, function* () {
      const oldSetting = this.plugin.settings.sortType.split("_");
      if (!key)
        key = oldSetting[0];
      if (!order)
        order = oldSetting[1];
      this.plugin.settings.sortType = `${key}_${order}`;
      yield this.plugin.saveSettings();
      this.plugin.setRoot(this.plugin.root);
    });
    const setOrderMethodTag = (key, order) => __async(this, null, function* () {
      const oldSetting = this.plugin.settings.sortTypeTag.split("_");
      if (!key)
        key = oldSetting[0];
      if (!order)
        order = oldSetting[1];
      this.plugin.settings.sortTypeTag = `${key}_${order}`;
      yield this.plugin.saveSettings();
      this.plugin.setRoot(this.plugin.root);
    });
    new import_obsidian3.Setting(containerEl).setName("Order method (Tags)").setDesc("how to order tags").addDropdown((dd) => {
      dd.addOptions(OrderKeyTag).setValue(this.plugin.settings.sortTypeTag.split("_")[0]).onChange((key) => setOrderMethodTag(key, null));
    }).addDropdown((dd) => {
      dd.addOptions(OrderDirection).setValue(this.plugin.settings.sortTypeTag.split("_")[1]).onChange((order) => setOrderMethodTag(null, order));
    });
    new import_obsidian3.Setting(containerEl).setName("Order method (Items)").setDesc("how to order items").addDropdown((dd) => {
      dd.addOptions(OrderKeyItem).setValue(this.plugin.settings.sortType.split("_")[0]).onChange((key) => setOrderMethod(key, null));
    }).addDropdown((dd) => {
      dd.addOptions(OrderDirection).setValue(this.plugin.settings.sortType.split("_")[1]).onChange((order) => setOrderMethod(null, order));
    });
    new import_obsidian3.Setting(containerEl).setName("Do not treat nested tags as dedicated levels").setDesc("Treat nested tags as normal tags").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.disableNestedTags).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.disableNestedTags = value;
        yield this.plugin.saveSettings();
      }));
    });
    new import_obsidian3.Setting(containerEl).setName("Reduce duplicated parents in nested tags").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.reduceNestedParent).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.reduceNestedParent = value;
        yield this.plugin.saveSettings();
      }));
    });
    new import_obsidian3.Setting(containerEl).setName("Use virtual tags").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.useVirtualTag).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.useVirtualTag = value;
        yield this.plugin.saveSettings();
      }));
    });
    new import_obsidian3.Setting(containerEl).setName("Hide Items").setDesc("Hide items on the landing or nested tags").addDropdown((dd) => {
      dd.addOptions(HideItemsType).setValue(this.plugin.settings.hideItems).onChange((key) => __async(this, null, function* () {
        if (key == "NONE" || key == "DEDICATED_INTERMIDIATES" || key == "ALL_EXCEPT_BOTTOM") {
          this.plugin.settings.hideItems = key;
        }
        yield this.plugin.saveSettings();
      }));
    });
    new import_obsidian3.Setting(containerEl).setName("Ignore note Tag").setDesc("If the note has the tag listed below, the note would be treated as there was not.").addTextArea((text2) => text2.setValue(this.plugin.settings.ignoreDocTags).setPlaceholder("test,test1,test2").onChange((value) => __async(this, null, function* () {
      this.plugin.settings.ignoreDocTags = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian3.Setting(containerEl).setName("Ignore Tag").setDesc("Tags in the list would be treated as there were not.").addTextArea((text2) => text2.setValue(this.plugin.settings.ignoreTags).setPlaceholder("test,test1,test2").onChange((value) => __async(this, null, function* () {
      this.plugin.settings.ignoreTags = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian3.Setting(containerEl).setName("Ignore Folders").setDesc("Ignore documents in specific folders.").addTextArea((text2) => text2.setValue(this.plugin.settings.ignoreFolders).setPlaceholder("template,list/standard_tags").onChange((value) => __async(this, null, function* () {
      this.plugin.settings.ignoreFolders = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian3.Setting(containerEl).setName("Tag scanning delay").setDesc("Sets the delay for reflecting metadata changes to the tag tree. (Plugin reload is required.)").addText((text2) => {
      text2 = text2.setValue(this.plugin.settings.scanDelay + "").onChange((value) => __async(this, null, function* () {
        const newDelay = Number.parseInt(value, 10);
        if (newDelay) {
          this.plugin.settings.scanDelay = newDelay;
          yield this.plugin.saveSettings();
        }
      }));
      text2.inputEl.setAttribute("type", "number");
      text2.inputEl.setAttribute("min", "250");
      return text2;
    });
  }
};
